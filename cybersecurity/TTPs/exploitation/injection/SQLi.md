# SQL Injection Attack
A vulnerability which allows an attacker to submit malicious [SQL](../../../../coding/languages/SQL.md) queries to a database via an insecure application or website. SQLi is usually leveraged to: view protected data, modify or delete data, compromise the underlying server or back end such as in a [denial of service](../denial-of-service.md) attack.
## Basic Mechanism
SQL is a *standard for languages* whose function is to manage data in *[RDBMS](../../../../coding/databases/RDBMS.md)* (relational databases) put forth by ISO. Different SQL languages exist (such as MySQL) and they all must follow the ISO standards for accessing, inserting, modifying, and deleting data, as well as for managing users and user authorization.
### In Web Apps
Many web applications use SQL databases to manage data related to users, products, and other kinds of data. Normally, when a client interacts with the frontend, data from the interaction is sent to the backend [application layer](../../../../networking/OSI/7-application/application-layer.md) running on the server. The backend code interacts with the data being sent from the front end and usually functions as a handler between the data and the database where it may be stored. This backend code/ framework will also handle data from the database being requested by the front end.

For example, when a user logs into a website, a request needs to be made from the front end to the backend to validate the supplied username and password. The user's credentials are likely stored in the database, so the backend will likely retrieve or query the existing user's information and compare the values supplied by the client (to decide whether the user attempting to login has supplied the correct credentials).
### Syntax
The most common languages used for relational databases are MySQL, Microsoft SQL, PostgresQL, and Oracle. Each vary in their syntax but they all do the same things regarding data and databases. The following is an example of a MySQL query for parsing the `users` table to retrieve a specific user entry:
```mysql
SELECT * FROM users WHERE user_name='tiddies'
```
### Example SQL Code (from a hacked box)
```cs
PS C:\inetpub\wwwroot> type login.cs
using System;
using System.Text;
using System.Data;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Collections;
using System.Security.Cryptography;
using System.Configuration;
using System.Collections.Specialized;
using System.Data.SqlClient;

namespace MyNamespace {
	public class MyClass : Page {
		protected System.Web.UI.WebControls.TextBox UsernameTextBox;
		protected System.Web.UI.WebControls.TextBox PasswordTextBox;
		protected System.Web.UI.WebControls.Button LoginButton;
		protected System.Web.UI.WebControls.Label MyLabel;

		protected void Page_Load(object sender, EventArgs e) {

		}

		protected void Login(Object sender, EventArgs e) {
			string dbUsername = "";
			string dbPassword = "";
			string passwordMD5 = "";
			bool isAuthentic = false;
			SqlConnection myConnection = new SqlConnection();
			myConnection.ConnectionString = ConfigurationManager.ConnectionStrings["myConnectionString"].ConnectionString;
			try {
				using (var sqlWrite = new SqlCommand("SELECT username, password FROM users WHERE username = '" + UsernameTextBox.Text.ToString() + "';", myConnection)) {
					myConnection.Open();
					SqlDataReader myReader = null;
					myReader = sqlWrite.ExecuteReader();
					if (myReader.HasRows) {
						while (myReader.Read()) {
							dbUsername = myReader["username"].ToString();
							dbPassword = myReader["password"].ToString();
						}
					}
					myConnection.Close();

					using (MD5 md5 = MD5.Create()) {
						byte[] inputBytes = System.Text.Encoding.ASCII.GetBytes(PasswordTextBox.Text.ToString());
						byte[] hashBytes = md5.ComputeHash(inputBytes);
	//				passwordMD5 = Convert.ToHexString(hashBytes);
						StringBuilder sb = new System.Text.StringBuilder();
						for (int i = 0; i < hashBytes.Length; i++) {
							sb.Append(hashBytes[i].ToString("X2"));
						}
						passwordMD5 = sb.ToString();
					}

					if (UsernameTextBox.Text.ToString() == dbUsername && passwordMD5 == dbPassword) {
						isAuthentic = true;
					}
				}
				if (!isAuthentic) {
					MyLabel.Text = "Invalid credentials. Please try again.";
				}
				else {
					Session["username"] = dbUsername;
					HttpContext.Current.Response.Redirect("/");
				}
			}
			catch (Exception ex) {
				MyLabel.Text = ex.ToString();
			}
		}
	}
}
```
## Identifying SQLi Manually
### Error-based Payloads
Consider this [PHP](../../../../coding/languages/PHP.md) code:
```php
<?php
$uname = $_POST['uname'];
$passwd =$_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```
Both the `uname` and `password` parameters are user-supplied input and make up the resulting SQL query string `sql_query`. Because `sql_query` is set to a string, we can try injecting a *closing quote* to pre-maturely close the string in the SQL statement. 
If we just close the quote, that will break the entire execution becuase the statement itself won't be properly terminated. In SQL, a statement is terminated with `;`, but if we inject `;` at the end of our injections, the remaining part of the statment (`AND password='&passwd'";`) would still be present. Because it's not a complete, syntactically correct SQL statement, it will also break the execution. 
#### Using comments
To prevent the trailing portion of the statement from breaking the statement (after we inject), we can use a SQL comment token (`--`) to comment out the hanging portion of the query. Our injection would effectively read like this during execution:
```sql
-- Original Query statement:
SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd';

-- New statement(s):
SELECT * FROM users WHERE user_name= 'trshpuppy' OR 1 = 1; --' AND password='$passwd'
```
We can also use `//` to prematurely terminate the SQL statement (in combination with the `--` token):
```sql
-- New statement(s):
SELECT * FROM users WHERE user_name= 'trshpuppy' OR 1 = 1; -- //'
```
The two forward slashes protects against any whitespace truncation employed by the web application.
#### Using the `in` operator
We can use the `in` operator and add it to our injection payload to see if we have unbounded control over database queries. 
```sql
'OR 1=1 in (select @@version) -- //
```
With this injection, we're comparing `1=1` (true) to what should be a numeric value (the version number). This should cause an error, and if the application repeats that error back to us, we know that our injection is being executed beyond what it was intended for. I.e. we are interacting directly with the database with no filtering or security measures in between.
Once we've established that, we know we can run whatever query we want. For example, if we want to dump all of the users from the user table, we could run this injection:
```sql
-- Dump the entire user table
'OR 1=1 in (select * from users) -- //

-- Dump just the password column:
'OR 1=1 in (select password from users) -- //

-- Dump the password of a specific user:
'OR 1=1 in (select password from users where user = 'admin') -- //
```
## Techniques
1. Modifying an SQL query to retrieve hidden data or additional results
2. Subverting the logic of the application by changing a query in a way that interfere's with the application's logic.
3. Extracting information about the database itself including its structure, version etc.
4. blind-SQLi where the results of a query are not returned in the application's response.
### UNION Attack
A [UNION attack](cybersecurity/TTPs/exploitation/injection/UNION-attack.md) can be used to retrieve data from a database table other than the one you're attacking from.
### Blind Injections
#### Boolean Based
[Boolean Based SQLi](../../../../OSCP/web-apps/SQLi/SQLi.md#Boolean%20Based%20SQLi) use boolean logic and the web application's response to `true` and `false` injected queries to identify SQLi.
#### Time Based
[Time Based SQLi](../../../../OSCP/web-apps/SQLi/SQLi.md#Time%20Based%20SQLi) uses boolean logic *as well as time/ sleep functions, etc.* to identify when an application is vulnerable to SQLi.
## Attack-flow example (retrieving hidden data)
A shopping application displays data about products in different categories. When a user clicks on the "gifts" categories, their browser requests the URL `https://insecure-website.com/products?category=Gifts` the application makes an SQL query to its database to retrieve information of the relevant products:
```sql
SELECT * FROM products WHERE category = `Gifts` AND released = 1
```
- `*` asks for 'all details' from the `products` table
- where the category is `Gifts` is present
- and `released` (a property of each product) is `1` (true) (hides products which are not released)
Assume unreleased products = `0`. An attacker can construct an attack using a similar URL: `https://insecure-website.com/products?category=Gifts --` which would result in the SQL query looking like:
```sql
SELECT * FROM products WHERE category = `Gifts`--` AND released = 1
```
The `--` is a comment indicator in SQL and would comment result in everything after it being commented out (not executable). This removes the rest of the query so that `AND released = 1` is no longer included.

If the attacker manipulates their input further, they can construct a URL which will show them all the products, including ones which are not meant to be seen: `https://insecure-website.com/products?category=Gifts'+OR+1=1--`. The resulting query would be:
```sql
SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1
```
This query returns all items where either the category is `Gifts` or 1 is equal to 1, and since 1=1 is always true, the query returns ALL ITEMS.

> [!References]
> - [Port Swigger](https://portswigger.net/web-security/sql-injection)
> - [Invicti: SQLi Cheat Sheet](https://www.invicti.com/blog/web-security/sql-injection-cheat-sheet/#UnionInjections)

> [!Related]
> - [My notes on SQLi](../../../../OSCP/web-apps/SQLi/SQLi.md) from OSCP


**boolean-based blind, time-based blind, error-based, UNION query-based, stacked queries and out-of-band**.